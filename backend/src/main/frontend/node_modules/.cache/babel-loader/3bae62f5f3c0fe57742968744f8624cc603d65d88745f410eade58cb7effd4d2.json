{"ast":null,"code":"'use strict';\n\nexports.isInteger = num => {\n  if (typeof num === 'number') {\n    return Number.isInteger(num);\n  }\n  if (typeof num === 'string' && num.trim() !== '') {\n    return Number.isInteger(Number(num));\n  }\n  return false;\n};\n\n/**\n * Find a node of the given type\n */\n\nexports.find = (node, type) => node.nodes.find(node => node.type === type);\n\n/**\n * Find a node of the given type\n */\n\nexports.exceedsLimit = function (min, max) {\n  let step = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n  let limit = arguments.length > 3 ? arguments[3] : undefined;\n  if (limit === false) return false;\n  if (!exports.isInteger(min) || !exports.isInteger(max)) return false;\n  return (Number(max) - Number(min)) / Number(step) >= limit;\n};\n\n/**\n * Escape the given node with '\\\\' before node.value\n */\n\nexports.escapeNode = function (block) {\n  let n = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  let type = arguments.length > 2 ? arguments[2] : undefined;\n  let node = block.nodes[n];\n  if (!node) return;\n  if (type && node.type === type || node.type === 'open' || node.type === 'close') {\n    if (node.escaped !== true) {\n      node.value = '\\\\' + node.value;\n      node.escaped = true;\n    }\n  }\n};\n\n/**\n * Returns true if the given brace node should be enclosed in literal braces\n */\n\nexports.encloseBrace = node => {\n  if (node.type !== 'brace') return false;\n  if (node.commas >> 0 + node.ranges >> 0 === 0) {\n    node.invalid = true;\n    return true;\n  }\n  return false;\n};\n\n/**\n * Returns true if a brace node is invalid.\n */\n\nexports.isInvalidBrace = block => {\n  if (block.type !== 'brace') return false;\n  if (block.invalid === true || block.dollar) return true;\n  if (block.commas >> 0 + block.ranges >> 0 === 0) {\n    block.invalid = true;\n    return true;\n  }\n  if (block.open !== true || block.close !== true) {\n    block.invalid = true;\n    return true;\n  }\n  return false;\n};\n\n/**\n * Returns true if a node is an open or close node\n */\n\nexports.isOpenOrClose = node => {\n  if (node.type === 'open' || node.type === 'close') {\n    return true;\n  }\n  return node.open === true || node.close === true;\n};\n\n/**\n * Reduce an array of text nodes.\n */\n\nexports.reduce = nodes => nodes.reduce((acc, node) => {\n  if (node.type === 'text') acc.push(node.value);\n  if (node.type === 'range') node.type = 'text';\n  return acc;\n}, []);\n\n/**\n * Flatten an array\n */\n\nexports.flatten = function () {\n  const result = [];\n  const flat = arr => {\n    for (let i = 0; i < arr.length; i++) {\n      let ele = arr[i];\n      Array.isArray(ele) ? flat(ele, result) : ele !== void 0 && result.push(ele);\n    }\n    return result;\n  };\n  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n    args[_key] = arguments[_key];\n  }\n  flat(args);\n  return result;\n};","map":{"version":3,"names":["exports","isInteger","num","Number","trim","find","node","type","nodes","exceedsLimit","min","max","step","arguments","length","undefined","limit","escapeNode","block","n","escaped","value","encloseBrace","commas","ranges","invalid","isInvalidBrace","dollar","open","close","isOpenOrClose","reduce","acc","push","flatten","result","flat","arr","i","ele","Array","isArray","_len","args","_key"],"sources":["C:/Users/user/Desktop/git/toy/src/main/frontend/node_modules/braces/lib/utils.js"],"sourcesContent":["'use strict';\n\nexports.isInteger = num => {\n  if (typeof num === 'number') {\n    return Number.isInteger(num);\n  }\n  if (typeof num === 'string' && num.trim() !== '') {\n    return Number.isInteger(Number(num));\n  }\n  return false;\n};\n\n/**\n * Find a node of the given type\n */\n\nexports.find = (node, type) => node.nodes.find(node => node.type === type);\n\n/**\n * Find a node of the given type\n */\n\nexports.exceedsLimit = (min, max, step = 1, limit) => {\n  if (limit === false) return false;\n  if (!exports.isInteger(min) || !exports.isInteger(max)) return false;\n  return ((Number(max) - Number(min)) / Number(step)) >= limit;\n};\n\n/**\n * Escape the given node with '\\\\' before node.value\n */\n\nexports.escapeNode = (block, n = 0, type) => {\n  let node = block.nodes[n];\n  if (!node) return;\n\n  if ((type && node.type === type) || node.type === 'open' || node.type === 'close') {\n    if (node.escaped !== true) {\n      node.value = '\\\\' + node.value;\n      node.escaped = true;\n    }\n  }\n};\n\n/**\n * Returns true if the given brace node should be enclosed in literal braces\n */\n\nexports.encloseBrace = node => {\n  if (node.type !== 'brace') return false;\n  if ((node.commas >> 0 + node.ranges >> 0) === 0) {\n    node.invalid = true;\n    return true;\n  }\n  return false;\n};\n\n/**\n * Returns true if a brace node is invalid.\n */\n\nexports.isInvalidBrace = block => {\n  if (block.type !== 'brace') return false;\n  if (block.invalid === true || block.dollar) return true;\n  if ((block.commas >> 0 + block.ranges >> 0) === 0) {\n    block.invalid = true;\n    return true;\n  }\n  if (block.open !== true || block.close !== true) {\n    block.invalid = true;\n    return true;\n  }\n  return false;\n};\n\n/**\n * Returns true if a node is an open or close node\n */\n\nexports.isOpenOrClose = node => {\n  if (node.type === 'open' || node.type === 'close') {\n    return true;\n  }\n  return node.open === true || node.close === true;\n};\n\n/**\n * Reduce an array of text nodes.\n */\n\nexports.reduce = nodes => nodes.reduce((acc, node) => {\n  if (node.type === 'text') acc.push(node.value);\n  if (node.type === 'range') node.type = 'text';\n  return acc;\n}, []);\n\n/**\n * Flatten an array\n */\n\nexports.flatten = (...args) => {\n  const result = [];\n  const flat = arr => {\n    for (let i = 0; i < arr.length; i++) {\n      let ele = arr[i];\n      Array.isArray(ele) ? flat(ele, result) : ele !== void 0 && result.push(ele);\n    }\n    return result;\n  };\n  flat(args);\n  return result;\n};\n"],"mappings":"AAAA,YAAY;;AAEZA,OAAO,CAACC,SAAS,GAAGC,GAAG,IAAI;EACzB,IAAI,OAAOA,GAAG,KAAK,QAAQ,EAAE;IAC3B,OAAOC,MAAM,CAACF,SAAS,CAACC,GAAG,CAAC;EAC9B;EACA,IAAI,OAAOA,GAAG,KAAK,QAAQ,IAAIA,GAAG,CAACE,IAAI,EAAE,KAAK,EAAE,EAAE;IAChD,OAAOD,MAAM,CAACF,SAAS,CAACE,MAAM,CAACD,GAAG,CAAC,CAAC;EACtC;EACA,OAAO,KAAK;AACd,CAAC;;AAED;AACA;AACA;;AAEAF,OAAO,CAACK,IAAI,GAAG,CAACC,IAAI,EAAEC,IAAI,KAAKD,IAAI,CAACE,KAAK,CAACH,IAAI,CAACC,IAAI,IAAIA,IAAI,CAACC,IAAI,KAAKA,IAAI,CAAC;;AAE1E;AACA;AACA;;AAEAP,OAAO,CAACS,YAAY,GAAG,UAACC,GAAG,EAAEC,GAAG,EAAsB;EAAA,IAApBC,IAAI,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAG,CAAC;EAAA,IAAEG,KAAK,GAAAH,SAAA,CAAAC,MAAA,OAAAD,SAAA,MAAAE,SAAA;EAC/C,IAAIC,KAAK,KAAK,KAAK,EAAE,OAAO,KAAK;EACjC,IAAI,CAAChB,OAAO,CAACC,SAAS,CAACS,GAAG,CAAC,IAAI,CAACV,OAAO,CAACC,SAAS,CAACU,GAAG,CAAC,EAAE,OAAO,KAAK;EACpE,OAAQ,CAACR,MAAM,CAACQ,GAAG,CAAC,GAAGR,MAAM,CAACO,GAAG,CAAC,IAAIP,MAAM,CAACS,IAAI,CAAC,IAAKI,KAAK;AAC9D,CAAC;;AAED;AACA;AACA;;AAEAhB,OAAO,CAACiB,UAAU,GAAG,UAACC,KAAK,EAAkB;EAAA,IAAhBC,CAAC,GAAAN,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAG,CAAC;EAAA,IAAEN,IAAI,GAAAM,SAAA,CAAAC,MAAA,OAAAD,SAAA,MAAAE,SAAA;EACtC,IAAIT,IAAI,GAAGY,KAAK,CAACV,KAAK,CAACW,CAAC,CAAC;EACzB,IAAI,CAACb,IAAI,EAAE;EAEX,IAAKC,IAAI,IAAID,IAAI,CAACC,IAAI,KAAKA,IAAI,IAAKD,IAAI,CAACC,IAAI,KAAK,MAAM,IAAID,IAAI,CAACC,IAAI,KAAK,OAAO,EAAE;IACjF,IAAID,IAAI,CAACc,OAAO,KAAK,IAAI,EAAE;MACzBd,IAAI,CAACe,KAAK,GAAG,IAAI,GAAGf,IAAI,CAACe,KAAK;MAC9Bf,IAAI,CAACc,OAAO,GAAG,IAAI;IACrB;EACF;AACF,CAAC;;AAED;AACA;AACA;;AAEApB,OAAO,CAACsB,YAAY,GAAGhB,IAAI,IAAI;EAC7B,IAAIA,IAAI,CAACC,IAAI,KAAK,OAAO,EAAE,OAAO,KAAK;EACvC,IAAKD,IAAI,CAACiB,MAAM,IAAI,CAAC,GAAGjB,IAAI,CAACkB,MAAM,IAAI,CAAC,KAAM,CAAC,EAAE;IAC/ClB,IAAI,CAACmB,OAAO,GAAG,IAAI;IACnB,OAAO,IAAI;EACb;EACA,OAAO,KAAK;AACd,CAAC;;AAED;AACA;AACA;;AAEAzB,OAAO,CAAC0B,cAAc,GAAGR,KAAK,IAAI;EAChC,IAAIA,KAAK,CAACX,IAAI,KAAK,OAAO,EAAE,OAAO,KAAK;EACxC,IAAIW,KAAK,CAACO,OAAO,KAAK,IAAI,IAAIP,KAAK,CAACS,MAAM,EAAE,OAAO,IAAI;EACvD,IAAKT,KAAK,CAACK,MAAM,IAAI,CAAC,GAAGL,KAAK,CAACM,MAAM,IAAI,CAAC,KAAM,CAAC,EAAE;IACjDN,KAAK,CAACO,OAAO,GAAG,IAAI;IACpB,OAAO,IAAI;EACb;EACA,IAAIP,KAAK,CAACU,IAAI,KAAK,IAAI,IAAIV,KAAK,CAACW,KAAK,KAAK,IAAI,EAAE;IAC/CX,KAAK,CAACO,OAAO,GAAG,IAAI;IACpB,OAAO,IAAI;EACb;EACA,OAAO,KAAK;AACd,CAAC;;AAED;AACA;AACA;;AAEAzB,OAAO,CAAC8B,aAAa,GAAGxB,IAAI,IAAI;EAC9B,IAAIA,IAAI,CAACC,IAAI,KAAK,MAAM,IAAID,IAAI,CAACC,IAAI,KAAK,OAAO,EAAE;IACjD,OAAO,IAAI;EACb;EACA,OAAOD,IAAI,CAACsB,IAAI,KAAK,IAAI,IAAItB,IAAI,CAACuB,KAAK,KAAK,IAAI;AAClD,CAAC;;AAED;AACA;AACA;;AAEA7B,OAAO,CAAC+B,MAAM,GAAGvB,KAAK,IAAIA,KAAK,CAACuB,MAAM,CAAC,CAACC,GAAG,EAAE1B,IAAI,KAAK;EACpD,IAAIA,IAAI,CAACC,IAAI,KAAK,MAAM,EAAEyB,GAAG,CAACC,IAAI,CAAC3B,IAAI,CAACe,KAAK,CAAC;EAC9C,IAAIf,IAAI,CAACC,IAAI,KAAK,OAAO,EAAED,IAAI,CAACC,IAAI,GAAG,MAAM;EAC7C,OAAOyB,GAAG;AACZ,CAAC,EAAE,EAAE,CAAC;;AAEN;AACA;AACA;;AAEAhC,OAAO,CAACkC,OAAO,GAAG,YAAa;EAC7B,MAAMC,MAAM,GAAG,EAAE;EACjB,MAAMC,IAAI,GAAGC,GAAG,IAAI;IAClB,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGD,GAAG,CAACvB,MAAM,EAAEwB,CAAC,EAAE,EAAE;MACnC,IAAIC,GAAG,GAAGF,GAAG,CAACC,CAAC,CAAC;MAChBE,KAAK,CAACC,OAAO,CAACF,GAAG,CAAC,GAAGH,IAAI,CAACG,GAAG,EAAEJ,MAAM,CAAC,GAAGI,GAAG,KAAK,KAAK,CAAC,IAAIJ,MAAM,CAACF,IAAI,CAACM,GAAG,CAAC;IAC7E;IACA,OAAOJ,MAAM;EACf,CAAC;EAAC,SAAAO,IAAA,GAAA7B,SAAA,CAAAC,MAAA,EARkB6B,IAAI,OAAAH,KAAA,CAAAE,IAAA,GAAAE,IAAA,MAAAA,IAAA,GAAAF,IAAA,EAAAE,IAAA;IAAJD,IAAI,CAAAC,IAAA,IAAA/B,SAAA,CAAA+B,IAAA;EAAA;EASxBR,IAAI,CAACO,IAAI,CAAC;EACV,OAAOR,MAAM;AACf,CAAC"},"metadata":{},"sourceType":"script","externalDependencies":[]}