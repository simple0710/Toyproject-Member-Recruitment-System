{"ast":null,"code":"\"use strict\";\n\nvar _regeneratorRuntime = require(\"C:/Users/user/Desktop/git/toy/src/main/frontend/node_modules/@babel/runtime/helpers/regeneratorRuntime.js\").default;\nvar _asyncToGenerator = require(\"C:/Users/user/Desktop/git/toy/src/main/frontend/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.typeImplementation = typeImplementation;\nvar _utils = require(\"../utils\");\nvar _click = require(\"../click\");\nvar _keyboard = require(\"../keyboard\");\nfunction typeImplementation(_x, _x2, _x3) {\n  return _typeImplementation.apply(this, arguments);\n}\nfunction _typeImplementation() {\n  _typeImplementation = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(element, text, _ref) {\n    var delay, _ref$skipClick, skipClick, _ref$skipAutoClose, skipAutoClose, _ref$initialSelection, initialSelectionStart, _ref$initialSelection2, initialSelectionEnd, currentElement, value, _ref2, selectionStart, selectionEnd, _ref3, promise, releaseAllKeys;\n    return _regeneratorRuntime().wrap(function _callee$(_context) {\n      while (1) switch (_context.prev = _context.next) {\n        case 0:\n          delay = _ref.delay, _ref$skipClick = _ref.skipClick, skipClick = _ref$skipClick === void 0 ? false : _ref$skipClick, _ref$skipAutoClose = _ref.skipAutoClose, skipAutoClose = _ref$skipAutoClose === void 0 ? false : _ref$skipAutoClose, _ref$initialSelection = _ref.initialSelectionStart, initialSelectionStart = _ref$initialSelection === void 0 ? undefined : _ref$initialSelection, _ref$initialSelection2 = _ref.initialSelectionEnd, initialSelectionEnd = _ref$initialSelection2 === void 0 ? undefined : _ref$initialSelection2;\n          if (!element.disabled) {\n            _context.next = 3;\n            break;\n          }\n          return _context.abrupt(\"return\");\n        case 3:\n          if (!skipClick) (0, _click.click)(element); // The focused element could change between each event, so get the currently active element each time\n          currentElement = function currentElement() {\n            return (0, _utils.getActiveElement)(element.ownerDocument);\n          }; // by default, a new element has its selection start and end at 0\n          // but most of the time when people call \"type\", they expect it to type\n          // at the end of the current input value. So, if the selection start\n          // and end are both the default of 0, then we'll go ahead and change\n          // them to the length of the current value.\n          // the only time it would make sense to pass the initialSelectionStart or\n          // initialSelectionEnd is if you have an input with a value and want to\n          // explicitly start typing with the cursor at 0. Not super common.\n          value = (0, _utils.getValue)(currentElement());\n          _ref2 = (0, _utils.getSelectionRange)(element), selectionStart = _ref2.selectionStart, selectionEnd = _ref2.selectionEnd;\n          if (value != null && (selectionStart === null || selectionStart === 0) && (selectionEnd === null || selectionEnd === 0)) {\n            (0, _utils.setSelectionRange)(currentElement(), initialSelectionStart != null ? initialSelectionStart : value.length, initialSelectionEnd != null ? initialSelectionEnd : value.length);\n          }\n          _ref3 = (0, _keyboard.keyboardImplementationWrapper)(text, {\n            delay: delay,\n            document: element.ownerDocument\n          }), promise = _ref3.promise, releaseAllKeys = _ref3.releaseAllKeys;\n          if (!(delay > 0)) {\n            _context.next = 12;\n            break;\n          }\n          _context.next = 12;\n          return promise;\n        case 12:\n          if (!skipAutoClose) {\n            releaseAllKeys();\n          } // eslint-disable-next-line consistent-return -- we need to return the internal Promise so that it is catchable if we don't await\n          return _context.abrupt(\"return\", promise);\n        case 14:\n        case \"end\":\n          return _context.stop();\n      }\n    }, _callee);\n  }));\n  return _typeImplementation.apply(this, arguments);\n}","map":{"version":3,"names":["_regeneratorRuntime","require","default","_asyncToGenerator","Object","defineProperty","exports","value","typeImplementation","_utils","_click","_keyboard","_x","_x2","_x3","_typeImplementation","apply","arguments","mark","_callee","element","text","_ref","delay","_ref$skipClick","skipClick","_ref$skipAutoClose","skipAutoClose","_ref$initialSelection","initialSelectionStart","_ref$initialSelection2","initialSelectionEnd","currentElement","_ref2","selectionStart","selectionEnd","_ref3","promise","releaseAllKeys","wrap","_callee$","_context","prev","next","undefined","disabled","abrupt","click","getActiveElement","ownerDocument","getValue","getSelectionRange","setSelectionRange","length","keyboardImplementationWrapper","document","stop"],"sources":["C:/Users/user/Desktop/git/toy/src/main/frontend/node_modules/@testing-library/user-event/dist/type/typeImplementation.js"],"sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.typeImplementation = typeImplementation;\n\nvar _utils = require(\"../utils\");\n\nvar _click = require(\"../click\");\n\nvar _keyboard = require(\"../keyboard\");\n\nasync function typeImplementation(element, text, {\n  delay,\n  skipClick = false,\n  skipAutoClose = false,\n  initialSelectionStart = undefined,\n  initialSelectionEnd = undefined\n}) {\n  // TODO: properly type guard\n  // we use this workaround for now to prevent changing behavior\n  if (element.disabled) return;\n  if (!skipClick) (0, _click.click)(element); // The focused element could change between each event, so get the currently active element each time\n\n  const currentElement = () => (0, _utils.getActiveElement)(element.ownerDocument); // by default, a new element has its selection start and end at 0\n  // but most of the time when people call \"type\", they expect it to type\n  // at the end of the current input value. So, if the selection start\n  // and end are both the default of 0, then we'll go ahead and change\n  // them to the length of the current value.\n  // the only time it would make sense to pass the initialSelectionStart or\n  // initialSelectionEnd is if you have an input with a value and want to\n  // explicitly start typing with the cursor at 0. Not super common.\n\n\n  const value = (0, _utils.getValue)(currentElement());\n  const {\n    selectionStart,\n    selectionEnd\n  } = (0, _utils.getSelectionRange)(element);\n\n  if (value != null && (selectionStart === null || selectionStart === 0) && (selectionEnd === null || selectionEnd === 0)) {\n    (0, _utils.setSelectionRange)(currentElement(), initialSelectionStart != null ? initialSelectionStart : value.length, initialSelectionEnd != null ? initialSelectionEnd : value.length);\n  }\n\n  const {\n    promise,\n    releaseAllKeys\n  } = (0, _keyboard.keyboardImplementationWrapper)(text, {\n    delay,\n    document: element.ownerDocument\n  });\n\n  if (delay > 0) {\n    await promise;\n  }\n\n  if (!skipAutoClose) {\n    releaseAllKeys();\n  } // eslint-disable-next-line consistent-return -- we need to return the internal Promise so that it is catchable if we don't await\n\n\n  return promise;\n}"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}